################################################################################
# This file was auto-generated by generate_state_variable_form.py
################################################################################
import numpy as np


def calculate_M(x, m1, m2, m3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    M = np.array([[J_1x, 0, -J_1x*np.sin(theta)], [0, -J_1y*np.sin(phi)**2 + J_1y + J_1z*np.sin(phi)**2 + J_2y + ell_1**2*m1 + ell_2**2*m2, (J_1y - J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta)], [-J_1x*np.sin(theta), (J_1y - J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta), J_1x*np.sin(theta)**2 + J_1y*np.sin(phi)**2*np.cos(theta)**2 + J_1z*np.cos(phi)**2*np.cos(theta)**2 + J_2x*np.sin(theta)**2 + J_2z*np.cos(theta)**2 + J_3z + ell_1**2*m1*np.cos(theta)**2 + ell_2**2*m2*np.cos(theta)**2 + m3*(ell_3x**2 + ell_3y**2)]])
    return M.squeeze()


def calculate_C(x, m1, m2, m3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    C = np.array([[-J_1x*psidot*thetadot*np.cos(theta) - psidot*(psidot*(J_1y - J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta)**2 + (1/2)*thetadot*(J_1y - J_1z)*np.cos(2*phi)*np.cos(theta)) - thetadot*((1/2)*psidot*(J_1y - J_1z)*np.cos(2*phi)*np.cos(theta) + (1/2)*thetadot*(-J_1y + J_1z)*np.sin(2*phi))], [(1/2)*J_1x*phidot*psidot*np.cos(theta) + 2*phidot*thetadot*(-J_1y + J_1z)*np.sin(phi)*np.cos(phi) + (1/2)*psidot*thetadot*(J_1y - J_1z)*np.sin(phi)*np.sin(theta)*np.cos(phi) + psidot*(J_1y - J_1z)*(-2*phidot*np.sin(phi)**2*np.cos(theta) + phidot*np.cos(theta) - thetadot*np.sin(phi)*np.sin(theta)*np.cos(phi)) - psidot*(-1/2*J_1x*phidot*np.cos(theta) + psidot*(J_1x - J_1y*np.sin(phi)**2 - J_1z*np.cos(phi)**2 + J_2x - J_2z - ell_1**2*m1 - ell_2**2*m2)*np.sin(theta)*np.cos(theta) - 1/2*thetadot*(J_1y - J_1z)*np.sin(phi)*np.sin(theta)*np.cos(phi))], [-J_1x*phidot*thetadot*np.cos(theta) - 2*psidot*(phidot*(-J_1y + J_1z)*np.sin(phi)*np.cos(phi)*np.cos(theta) + thetadot*(-J_1x + J_1y*np.sin(phi)**2 + J_1z*np.cos(phi)**2 - J_2x + J_2z + ell_1**2*m1 + ell_2**2*m2)*np.sin(theta))*np.cos(theta) + thetadot*(J_1y - J_1z)*(-2*phidot*np.sin(phi)**2*np.cos(theta) + phidot*np.cos(theta) - thetadot*np.sin(phi)*np.sin(theta)*np.cos(phi))]])
    return C.squeeze()


def calculate_dP_dq(x, m1, m2, m3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    dP_dq = np.array([[0], [ell_1*g*m1*np.cos(theta) + ell_2*g*m2*np.cos(theta)], [0]])
    return dP_dq.squeeze()


def calculate_tau(x, u, m1, m2, m3, J_1x, J_1y, J_1z, J_2x, J_2y, J_2z, J_3x, J_3y, J_3z, ell_1, ell_2, ell_3x, ell_3y, ell_3z, ell_T, d, g):
    [phi, theta, psi, phidot, thetadot, psidot] = x.flatten()  # ensure 1D
    [f_l, f_r] = u.flatten()  # ensure 1D
    tau = np.array([[d*(f_l - f_r)], [ell_T*(f_l + f_r)*np.cos(phi)], [(-d*f_l + d*f_r)*np.sin(theta) + (ell_T*f_l + ell_T*f_r)*np.sin(phi)*np.cos(theta)]])
    return tau.squeeze()
